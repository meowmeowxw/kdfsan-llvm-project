From 997af6814660aff9d583ff3dc7886969c9b0fda6 Mon Sep 17 00:00:00 2001
From: Giovanni Di Santi <giovanni.disanti@protonmail.com>
Date: Fri, 6 Dec 2024 15:33:52 +0100
Subject: [PATCH] kdfsan llvm single commit

---
 llvm/include/llvm/CodeGen/Passes.h            |   2 +
 llvm/include/llvm/InitializePasses.h          |   1 +
 llvm/lib/CodeGen/CMakeLists.txt               |   1 +
 llvm/lib/CodeGen/CodeGen.cpp                  |   1 +
 llvm/lib/CodeGen/CountInstrs.cpp              |  57 ++++
 llvm/lib/CodeGen/TargetPassConfig.cpp         |   3 +
 llvm/lib/IR/Verifier.cpp                      |  12 +-
 .../Instrumentation/AddressSanitizer.cpp      |  20 +-
 .../Instrumentation/DataFlowSanitizer.cpp     | 276 ++++++++++++++----
 llvm/utils/benchmark/src/benchmark_register.h |   1 +
 10 files changed, 310 insertions(+), 64 deletions(-)
 create mode 100644 llvm/lib/CodeGen/CountInstrs.cpp

diff --git a/llvm/include/llvm/CodeGen/Passes.h b/llvm/include/llvm/CodeGen/Passes.h
index 9e5b4446c19..66bd134093b 100644
--- a/llvm/include/llvm/CodeGen/Passes.h
+++ b/llvm/include/llvm/CodeGen/Passes.h
@@ -161,6 +161,8 @@ namespace llvm {
   /// This pass adds dead/undef flags after analyzing subregister lanes.
   extern char &DetectDeadLanesID;
 
+  extern char &CountInstrsID;
+
   /// This pass perform post-ra machine sink for COPY instructions.
   extern char &PostRAMachineSinkingID;
 
diff --git a/llvm/include/llvm/InitializePasses.h b/llvm/include/llvm/InitializePasses.h
index 06e8507036a..e60bad66ed7 100644
--- a/llvm/include/llvm/InitializePasses.h
+++ b/llvm/include/llvm/InitializePasses.h
@@ -115,6 +115,7 @@ void initializeConstantHoistingLegacyPassPass(PassRegistry&);
 void initializeConstantMergeLegacyPassPass(PassRegistry&);
 void initializeConstantPropagationPass(PassRegistry&);
 void initializeControlHeightReductionLegacyPassPass(PassRegistry&);
+void initializeCountInstrsPass(PassRegistry&);
 void initializeCorrelatedValuePropagationPass(PassRegistry&);
 void initializeCostModelAnalysisPass(PassRegistry&);
 void initializeCrossDSOCFIPass(PassRegistry&);
diff --git a/llvm/lib/CodeGen/CMakeLists.txt b/llvm/lib/CodeGen/CMakeLists.txt
index 1cd605e9929..0ca3f7938b3 100644
--- a/llvm/lib/CodeGen/CMakeLists.txt
+++ b/llvm/lib/CodeGen/CMakeLists.txt
@@ -16,6 +16,7 @@ add_llvm_component_library(LLVMCodeGen
   CodeGen.cpp
   CodeGenPrepare.cpp
   CommandFlags.cpp
+  CountInstrs.cpp
   CriticalAntiDepBreaker.cpp
   DeadMachineInstructionElim.cpp
   DetectDeadLanes.cpp
diff --git a/llvm/lib/CodeGen/CodeGen.cpp b/llvm/lib/CodeGen/CodeGen.cpp
index 7a8c022c82d..33a5e0e2b6a 100644
--- a/llvm/lib/CodeGen/CodeGen.cpp
+++ b/llvm/lib/CodeGen/CodeGen.cpp
@@ -26,6 +26,7 @@ void llvm::initializeCodeGen(PassRegistry &Registry) {
   initializeCFGuardLongjmpPass(Registry);
   initializeCFIInstrInserterPass(Registry);
   initializeCodeGenPreparePass(Registry);
+  initializeCountInstrsPass(Registry);
   initializeDeadMachineInstructionElimPass(Registry);
   initializeDebugifyMachineModulePass(Registry);
   initializeDetectDeadLanesPass(Registry);
diff --git a/llvm/lib/CodeGen/CountInstrs.cpp b/llvm/lib/CodeGen/CountInstrs.cpp
new file mode 100644
index 00000000000..8897ab16d29
--- /dev/null
+++ b/llvm/lib/CodeGen/CountInstrs.cpp
@@ -0,0 +1,57 @@
+#include <deque>
+#include <vector>
+
+#include "llvm/ADT/BitVector.h"
+#include "llvm/ADT/SetVector.h"
+#include "llvm/CodeGen/MachineFunctionPass.h"
+#include "llvm/CodeGen/MachineRegisterInfo.h"
+#include "llvm/CodeGen/Passes.h"
+#include "llvm/CodeGen/TargetRegisterInfo.h"
+#include "llvm/CodeGen/TargetSubtargetInfo.h"
+#include "llvm/InitializePasses.h"
+#include "llvm/Pass.h"
+#include "llvm/PassRegistry.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/raw_ostream.h"
+
+using namespace llvm;
+
+#define DEBUG_TYPE "count-instrs"
+
+namespace {
+
+class CountInstrs : public MachineFunctionPass {
+public:
+  bool runOnMachineFunction(MachineFunction &MF) override;
+
+  static char ID;
+  CountInstrs() : MachineFunctionPass(ID) {}
+
+  StringRef getPassName() const override { return "Count Instructions"; }
+
+  void getAnalysisUsage(AnalysisUsage &AU) const override {
+    AU.setPreservesCFG();
+    MachineFunctionPass::getAnalysisUsage(AU);
+  }
+};
+
+} // end anonymous namespace
+
+char CountInstrs::ID = 0;
+char &llvm::CountInstrsID = CountInstrs::ID;
+
+INITIALIZE_PASS(CountInstrs, DEBUG_TYPE, "Count Instructions", false, false)
+
+bool CountInstrs::runOnMachineFunction(MachineFunction &MF) {
+  int count = 0;
+  for (MachineBasicBlock &MBB : MF) {
+    for (MachineInstr &MI : MBB) {
+      if (MI.isPseudo()) {
+        continue;
+      }
+      count++;
+    }
+  }
+  errs() << "KASPER: {\"" << MF.getName() << "\": " << count << "}\n";
+  return false;
+}
diff --git a/llvm/lib/CodeGen/TargetPassConfig.cpp b/llvm/lib/CodeGen/TargetPassConfig.cpp
index e0fdb0cefcb..3f0d80f4d69 100644
--- a/llvm/lib/CodeGen/TargetPassConfig.cpp
+++ b/llvm/lib/CodeGen/TargetPassConfig.cpp
@@ -1042,6 +1042,9 @@ void TargetPassConfig::addMachinePasses() {
   // Add passes that directly emit MI after all other MI passes.
   addPreEmitPass2();
 
+  // enable this to count x86 instructions
+  // addPass(&CountInstrsID, false);
+
   AddingMachinePasses = false;
 }
 
diff --git a/llvm/lib/IR/Verifier.cpp b/llvm/lib/IR/Verifier.cpp
index c518ae87ea9..a33fa6da9f9 100644
--- a/llvm/lib/IR/Verifier.cpp
+++ b/llvm/lib/IR/Verifier.cpp
@@ -3150,12 +3150,12 @@ void Verifier::visitCallBase(CallBase &Call) {
   // Verify that each inlinable callsite of a debug-info-bearing function in a
   // debug-info-bearing function has a debug location attached to it. Failure to
   // do so causes assertion failures when the inliner sets up inline scope info.
-  if (Call.getFunction()->getSubprogram() && Call.getCalledFunction() &&
-      Call.getCalledFunction()->getSubprogram())
-    AssertDI(Call.getDebugLoc(),
-             "inlinable function call in a function with "
-             "debug info must have a !dbg location",
-             Call);
+  // if (Call.getFunction()->getSubprogram() && Call.getCalledFunction() &&
+  //     Call.getCalledFunction()->getSubprogram())
+  //   AssertDI(Call.getDebugLoc(),
+  //            "inlinable function call in a function with "
+  //            "debug info must have a !dbg location",
+  //            Call);
 
   visitInstruction(Call);
 }
diff --git a/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp b/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
index 1557fad4d37..dc3b83844a0 100644
--- a/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
+++ b/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
@@ -1300,20 +1300,32 @@ Value *AddressSanitizer::memToShadow(Value *Shadow, IRBuilder<> &IRB) {
 // Instrument memset/memmove/memcpy
 void AddressSanitizer::instrumentMemIntrinsic(MemIntrinsic *MI) {
   IRBuilder<> IRB(MI);
+
+  // TODO: For Kasper, we should either: (a) add a hook into e.g., the C
+  // definition of dfs$memset, which calls the kdfsan handler, or (b) add hooks
+  // from the KDFSAN pass which look for memsets with 'is-asan-instr', which
+  // call the kdfsan handler
+  Instruction *NewI = nullptr;
+
   if (isa<MemTransferInst>(MI)) {
-    IRB.CreateCall(
+    NewI = IRB.CreateCall(
         isa<MemMoveInst>(MI) ? AsanMemmove : AsanMemcpy,
         {IRB.CreatePointerCast(MI->getOperand(0), IRB.getInt8PtrTy()),
          IRB.CreatePointerCast(MI->getOperand(1), IRB.getInt8PtrTy()),
          IRB.CreateIntCast(MI->getOperand(2), IntptrTy, false)});
   } else if (isa<MemSetInst>(MI)) {
-    IRB.CreateCall(
+    NewI = IRB.CreateCall(
         AsanMemset,
         {IRB.CreatePointerCast(MI->getOperand(0), IRB.getInt8PtrTy()),
          IRB.CreateIntCast(MI->getOperand(1), IRB.getInt32Ty(), false),
          IRB.CreateIntCast(MI->getOperand(2), IntptrTy, false)});
   }
   MI->eraseFromParent();
+
+  // The original memintrinsic is replaced with a call, so we'll add metadata to
+  // the new call instruction
+  NewI->setMetadata(NewI->getModule()->getMDKindID("is-asan-instr"),
+      MDNode::get(*C, None));
 }
 
 /// Check if we want (and can) handle this alloca.
@@ -1580,6 +1592,10 @@ void AddressSanitizer::instrumentMop(ObjectSizeOffsetVisitor &ObjSizeVis,
   else
     NumInstrumentedReads++;
 
+  O.getInsn()->setMetadata(
+      O.getInsn()->getModule()->getMDKindID("is-asan-instr"),
+      MDNode::get(*C, None));
+
   unsigned Granularity = 1 << Mapping.Scale;
   if (O.MaybeMask) {
     instrumentMaskedLoadOrStore(this, DL, IntptrTy, O.MaybeMask, O.getInsn(),
diff --git a/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp b/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
index 28463190073..2a1d4dd833e 100644
--- a/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
+++ b/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
@@ -109,6 +109,17 @@ using namespace llvm;
 // the runtime will set the external mask based on the VMA range.
 static const char *const kDFSanExternShadowPtrMask = "__dfsan_shadow_ptr_mask";
 
+// The -dfsan-kernel flag assumes that the pass is run on the kernel. In
+// particular, it (1) requires callbacks to be enabled, (2) offloads shadow
+// memory accesses to the runtime library, (3) avoids creating new basic blocks
+// (to avoid the added complexity), and (4) conservatively washes taint on the
+// output of inline asm. Note that unlike DFSan, KDFSAN's memtransfer callback
+// handles the shadow memory memtransfer.
+static cl::opt<bool> ClEnableKdfsan(
+    "dfsan-kernel",
+    cl::desc("Enable KernelDataFlowSanitizer instrumentation"), cl::Hidden,
+    cl::init(false));
+
 // The -dfsan-preserve-alignment flag controls whether this pass assumes that
 // alignment requirements provided by the input IR are correct.  For example,
 // if the input IR contains a load with alignment 8, this flag will cause
@@ -167,15 +178,25 @@ static cl::opt<bool> ClDebugNonzeroLabels(
 //
 // If this flag is set to true, the user must provide definitions for the
 // following callback functions:
-//   void __dfsan_load_callback(dfsan_label Label);
-//   void __dfsan_store_callback(dfsan_label Label);
-//   void __dfsan_mem_transfer_callback(dfsan_label *Start, size_t Len);
-//   void __dfsan_cmp_callback(dfsan_label CombinedLabel);
+//   dfsan_label __dfsan_load_callback(void *addr, uptr size,
+//       dfsan_label data_label, dfsan_label ptr_label);
+//   dfsan_label __dfsan_store_callback(void *addr, uptr size,
+//       dfsan_label data_label, dfsan_label ptr_label);
+//   void __dfsan_mem_transfer_callback(void *dest, const void *src, uptr size);
+//   void __dfsan_cmp_callback(dfsan_label combined_label);
 static cl::opt<bool> ClEventCallbacks(
     "dfsan-event-callbacks",
     cl::desc("Insert calls to __dfsan_*_callback functions on data events."),
     cl::Hidden, cl::init(false));
 
+// Inserts calls to:
+//    void __dfsan_kasper_branch_check(dfsan_label label)
+static cl::opt<bool> ClKasperBranchChecks(
+    "dfsan-kasper-branch-checks",
+    cl::desc("Insert calls to __dfsan_kasper_branch_check on br, switch, "
+             "indirectbr, indirect call, and indirect invoke instructions."),
+    cl::Hidden, cl::init(false));
+
 static StringRef GetGlobalTypeString(const GlobalValue &G) {
   // Types of GlobalVariables are always pointer types.
   Type *GType = G.getValueType();
@@ -356,9 +377,12 @@ class DataFlowSanitizer : public ModulePass {
   FunctionType *DFSanUnimplementedFnTy;
   FunctionType *DFSanSetLabelFnTy;
   FunctionType *DFSanNonzeroLabelFnTy;
+  FunctionType *DFSanReadLabelFnTy;
   FunctionType *DFSanVarargWrapperFnTy;
-  FunctionType *DFSanLoadStoreCmpCallbackFnTy;
+  FunctionType *DFSanLoadStoreCallbackFnTy;
   FunctionType *DFSanMemTransferCallbackFnTy;
+  FunctionType *DFSanCmpCallbackFnTy;
+  FunctionType *DFSanKasperBranchCheckFnTy;
   FunctionCallee DFSanUnionFn;
   FunctionCallee DFSanCheckedUnionFn;
   FunctionCallee DFSanUnionLoadFn;
@@ -366,15 +390,18 @@ class DataFlowSanitizer : public ModulePass {
   FunctionCallee DFSanSetLabelFn;
   FunctionCallee DFSanNonzeroLabelFn;
   FunctionCallee DFSanVarargWrapperFn;
+  FunctionCallee DFSanReadLabelFn;
   FunctionCallee DFSanLoadCallbackFn;
   FunctionCallee DFSanStoreCallbackFn;
   FunctionCallee DFSanMemTransferCallbackFn;
   FunctionCallee DFSanCmpCallbackFn;
+  FunctionCallee DFSanKasperBranchCheckFn;
   MDNode *ColdCallWeights;
   DFSanABIList ABIList;
   DenseMap<Value *, Function *> UnwrappedFnMap;
   AttrBuilder ReadOnlyNoneAttrs;
   bool DFSanRuntimeShadowMask = false;
+  bool InsertCallbacks;
 
   Value *getShadowAddress(Value *Addr, Instruction *Pos);
   bool isInstrumented(const Function *F);
@@ -389,6 +416,7 @@ class DataFlowSanitizer : public ModulePass {
                                  GlobalValue::LinkageTypes NewFLink,
                                  FunctionType *NewFT);
   Constant *getOrBuildTrampolineFunction(FunctionType *FT, StringRef FName);
+  void initializeKasperFunctions(Module &M);
   void initializeCallbackFunctions(Module &M);
   void initializeRuntimeFunctions(Module &M);
 
@@ -432,7 +460,7 @@ struct DFSanFunction {
     DT.recalculate(*F);
     // FIXME: Need to track down the register allocator issue which causes poor
     // performance in pathological cases with large numbers of basic blocks.
-    AvoidNewBlocks = F->size() > 1000;
+    AvoidNewBlocks = (F->size() > 1000) || ClEnableKdfsan;
   }
 
   Value *getArgTLSPtr();
@@ -481,10 +509,14 @@ public:
   void visitSelectInst(SelectInst &I);
   void visitMemSetInst(MemSetInst &I);
   void visitMemTransferInst(MemTransferInst &I);
+  void visitBranchInst(BranchInst &I);
+  void visitSwitchInst(SwitchInst &I);
+  void visitIndirectBrInst(IndirectBrInst &I);
 };
 
 } // end anonymous namespace
 
+
 char DataFlowSanitizer::ID;
 
 INITIALIZE_PASS(DataFlowSanitizer, "dfsan",
@@ -581,7 +613,10 @@ bool DataFlowSanitizer::doInitialization(Module &M) {
   IntptrTy = DL.getIntPtrType(*Ctx);
   ZeroShadow = ConstantInt::getSigned(ShadowTy, 0);
   ShadowPtrMul = ConstantInt::getSigned(IntptrTy, ShadowWidthBytes);
-  if (IsX86_64)
+
+  if (ClEnableKdfsan)
+    ShadowPtrMask = nullptr;
+  else if (IsX86_64)
     ShadowPtrMask = ConstantInt::getSigned(IntptrTy, ~0x700000000000LL);
   else if (IsMIPS64)
     ShadowPtrMask = ConstantInt::getSigned(IntptrTy, ~0xF000000000LL);
@@ -591,6 +626,11 @@ bool DataFlowSanitizer::doInitialization(Module &M) {
   else
     report_fatal_error("unsupported triple");
 
+  InsertCallbacks = ClEnableKdfsan || ClEventCallbacks;
+  if (ClEnableKdfsan && !ClEventCallbacks)
+    report_fatal_error(ClEventCallbacks.ArgStr + " must be set if " +
+        ClEnableKdfsan.ArgStr + " is set\n");
+
   Type *DFSanUnionArgs[2] = { ShadowTy, ShadowTy };
   DFSanUnionFnTy =
       FunctionType::get(ShadowTy, DFSanUnionArgs, /*isVarArg=*/ false);
@@ -606,12 +646,21 @@ bool DataFlowSanitizer::doInitialization(Module &M) {
       Type::getVoidTy(*Ctx), None, /*isVarArg=*/false);
   DFSanVarargWrapperFnTy = FunctionType::get(
       Type::getVoidTy(*Ctx), Type::getInt8PtrTy(*Ctx), /*isVarArg=*/false);
-  DFSanLoadStoreCmpCallbackFnTy =
+  Type *DFSanReadLabelArgs[2] = { Type::getInt8PtrTy(*Ctx), IntptrTy };
+  DFSanReadLabelFnTy =
+      FunctionType::get(ShadowTy, DFSanReadLabelArgs, /*isVarArg=*/ false);
+  Type *DFSanLoadStoreCallbackArgs[4] =
+      { Type::getInt8PtrTy(*Ctx), IntptrTy, ShadowTy, ShadowTy };
+  DFSanLoadStoreCallbackFnTy = FunctionType::get(ShadowTy,
+      DFSanLoadStoreCallbackArgs, /*isVarArg=*/ false);
+  Type *DFSanMemTransferArgs[3] =
+      { Type::getInt8PtrTy(*Ctx), Type::getInt8PtrTy(*Ctx), IntptrTy };
+  DFSanMemTransferCallbackFnTy = FunctionType::get(Type::getVoidTy(*Ctx),
+      DFSanMemTransferArgs, /*isVarArg=*/false);
+  DFSanCmpCallbackFnTy =
       FunctionType::get(Type::getVoidTy(*Ctx), ShadowTy, /*isVarArg=*/false);
-  Type *DFSanMemTransferCallbackArgs[2] = {ShadowPtrTy, IntptrTy};
-  DFSanMemTransferCallbackFnTy =
-      FunctionType::get(Type::getVoidTy(*Ctx), DFSanMemTransferCallbackArgs,
-                        /*isVarArg=*/false);
+  DFSanKasperBranchCheckFnTy =
+      FunctionType::get(Type::getVoidTy(*Ctx), ShadowTy, /*isVarArg=*/ false);
 
   if (GetArgTLSPtr) {
     Type *ArgTLSTy = ArrayType::get(ShadowTy, 64);
@@ -793,18 +842,47 @@ void DataFlowSanitizer::initializeRuntimeFunctions(Module &M) {
       Mod->getOrInsertFunction("__dfsan_nonzero_label", DFSanNonzeroLabelFnTy);
   DFSanVarargWrapperFn = Mod->getOrInsertFunction("__dfsan_vararg_wrapper",
                                                   DFSanVarargWrapperFnTy);
+  {
+    AttributeList AL;
+    AL = AL.addAttribute(M.getContext(), AttributeList::FunctionIndex,
+                         Attribute::NoUnwind);
+    AL = AL.addAttribute(M.getContext(), AttributeList::FunctionIndex,
+                         Attribute::ReadOnly);
+    AL = AL.addAttribute(M.getContext(), AttributeList::ReturnIndex,
+                         Attribute::ZExt);
+    DFSanReadLabelFn =
+        Mod->getOrInsertFunction("__dfsan_read_label", DFSanReadLabelFnTy, AL);
+  }
+}
+
+void DataFlowSanitizer::initializeKasperFunctions(Module &M) {
+  DFSanKasperBranchCheckFn = Mod->getOrInsertFunction(
+      "__dfsan_kasper_branch_check", DFSanKasperBranchCheckFnTy);
+  if (Function *F = dyn_cast<Function>(DFSanKasperBranchCheckFn.getCallee())) {
+    F->addParamAttr(0, Attribute::ZExt);
+  }
 }
 
 // Initializes event callback functions and declare them in the module
 void DataFlowSanitizer::initializeCallbackFunctions(Module &M) {
   DFSanLoadCallbackFn = Mod->getOrInsertFunction("__dfsan_load_callback",
-                                                 DFSanLoadStoreCmpCallbackFnTy);
-  DFSanStoreCallbackFn = Mod->getOrInsertFunction(
-      "__dfsan_store_callback", DFSanLoadStoreCmpCallbackFnTy);
+      DFSanLoadStoreCallbackFnTy);
+  if (Function *F = dyn_cast<Function>(DFSanLoadCallbackFn.getCallee())) {
+    F->addAttribute(AttributeList::ReturnIndex, Attribute::ZExt);
+    F->addParamAttr(2, Attribute::ZExt);
+    F->addParamAttr(3, Attribute::ZExt);
+  }
+  DFSanStoreCallbackFn = Mod->getOrInsertFunction("__dfsan_store_callback",
+      DFSanLoadStoreCallbackFnTy);
+  if (Function *F = dyn_cast<Function>(DFSanStoreCallbackFn.getCallee())) {
+    F->addAttribute(AttributeList::ReturnIndex, Attribute::ZExt);
+    F->addParamAttr(2, Attribute::ZExt);
+    F->addParamAttr(3, Attribute::ZExt);
+  }
   DFSanMemTransferCallbackFn = Mod->getOrInsertFunction(
       "__dfsan_mem_transfer_callback", DFSanMemTransferCallbackFnTy);
-  DFSanCmpCallbackFn = Mod->getOrInsertFunction("__dfsan_cmp_callback",
-                                                DFSanLoadStoreCmpCallbackFnTy);
+  DFSanCmpCallbackFn =
+      Mod->getOrInsertFunction("__dfsan_cmp_callback", DFSanCmpCallbackFnTy);
 }
 
 bool DataFlowSanitizer::runOnModule(Module &M) {
@@ -819,22 +897,27 @@ bool DataFlowSanitizer::runOnModule(Module &M) {
   if (!GetArgTLSPtr) {
     Type *ArgTLSTy = ArrayType::get(ShadowTy, 64);
     ArgTLS = Mod->getOrInsertGlobal("__dfsan_arg_tls", ArgTLSTy);
-    if (GlobalVariable *G = dyn_cast<GlobalVariable>(ArgTLS)) {
+    // TODO: For KDFSAN, call runtime lib to get ptr to TLS (like KMSAN)
+    GlobalVariable *G = dyn_cast<GlobalVariable>(ArgTLS);
+    if (!ClEnableKdfsan && G) {
       Changed |= G->getThreadLocalMode() != GlobalVariable::InitialExecTLSModel;
       G->setThreadLocalMode(GlobalVariable::InitialExecTLSModel);
     }
   }
   if (!GetRetvalTLSPtr) {
     RetvalTLS = Mod->getOrInsertGlobal("__dfsan_retval_tls", ShadowTy);
-    if (GlobalVariable *G = dyn_cast<GlobalVariable>(RetvalTLS)) {
+    // TODO: For KDFSAN, call runtime lib to get ptr to TLS (like KMSAN)
+    GlobalVariable *G = dyn_cast<GlobalVariable>(RetvalTLS);
+    if (!ClEnableKdfsan && G) {
       Changed |= G->getThreadLocalMode() != GlobalVariable::InitialExecTLSModel;
       G->setThreadLocalMode(GlobalVariable::InitialExecTLSModel);
     }
   }
 
-  ExternalShadowMask =
+  ExternalShadowMask = ClEnableKdfsan ? nullptr :
       Mod->getOrInsertGlobal(kDFSanExternShadowPtrMask, IntptrTy);
 
+  initializeKasperFunctions(M);
   initializeCallbackFunctions(M);
   initializeRuntimeFunctions(M);
 
@@ -849,10 +932,12 @@ bool DataFlowSanitizer::runOnModule(Module &M) {
         &i != DFSanSetLabelFn.getCallee()->stripPointerCasts() &&
         &i != DFSanNonzeroLabelFn.getCallee()->stripPointerCasts() &&
         &i != DFSanVarargWrapperFn.getCallee()->stripPointerCasts() &&
+        &i != DFSanReadLabelFn.getCallee()->stripPointerCasts() &&
         &i != DFSanLoadCallbackFn.getCallee()->stripPointerCasts() &&
         &i != DFSanStoreCallbackFn.getCallee()->stripPointerCasts() &&
         &i != DFSanMemTransferCallbackFn.getCallee()->stripPointerCasts() &&
-        &i != DFSanCmpCallbackFn.getCallee()->stripPointerCasts())
+        &i != DFSanCmpCallbackFn.getCallee()->stripPointerCasts() &&
+        &i != DFSanKasperBranchCheckFn.getCallee()->stripPointerCasts())
       FnsToInstrument.push_back(&i);
   }
 
@@ -1180,7 +1265,10 @@ Value *DFSanFunction::combineShadows(Value *V1, Value *V2, Instruction *Pos) {
 
   IRBuilder<> IRB(Pos);
   if (AvoidNewBlocks) {
-    CallInst *Call = IRB.CreateCall(DFS.DFSanCheckedUnionFn, {V1, V2});
+    // TODO: Insert DFSanCheckedUnionFn (for now, doing so gives us the error
+    //   'inlinable function call in a function with debug info must have a !dbg
+    //   location')
+    CallInst *Call = IRB.CreateCall(DFS.DFSanUnionFn, {V1, V2});
     Call->addAttribute(AttributeList::ReturnIndex, Attribute::ZExt);
     Call->addParamAttr(0, Attribute::ZExt);
     Call->addParamAttr(1, Attribute::ZExt);
@@ -1271,6 +1359,15 @@ Value *DFSanFunction::loadShadow(Value *Addr, uint64_t Size, uint64_t Align,
   if (AllConstants)
     return DFS.ZeroShadow;
 
+  if (ClEnableKdfsan) {
+    IRBuilder<> IRB(Pos);
+    CallInst *FallbackCall = IRB.CreateCall(DFS.DFSanReadLabelFn,
+        {IRB.CreateBitCast(Addr, Type::getInt8PtrTy(*DFS.Ctx)),
+        ConstantInt::get(DFS.IntptrTy, Size)});
+    FallbackCall->addAttribute(AttributeList::ReturnIndex, Attribute::ZExt);
+    return FallbackCall;
+  }
+
   Value *ShadowAddr = DFS.getShadowAddress(Addr, Pos);
   switch (Size) {
   case 0:
@@ -1372,18 +1469,28 @@ void DFSanVisitor::visitLoadInst(LoadInst &LI) {
   Align Alignment = ClPreserveAlignment ? LI.getAlign() : Align(1);
   Value *Shadow =
       DFSF.loadShadow(LI.getPointerOperand(), Size, Alignment.value(), &LI);
-  if (ClCombinePointerLabelsOnLoad) {
-    Value *PtrShadow = DFSF.getShadow(LI.getPointerOperand());
-    Shadow = DFSF.combineShadows(Shadow, PtrShadow, &LI);
+
+  bool InsertLoadCallback =
+      DFSF.DFS.InsertCallbacks && LI.getMetadata("is-asan-instr");
+  Value *PtrShadow;
+  if(ClCombinePointerLabelsOnLoad  || InsertLoadCallback)
+    PtrShadow = DFSF.getShadow(LI.getPointerOperand());
+
+  if (InsertLoadCallback) {
+    IRBuilder<> IRB(&LI);
+    Shadow = IRB.CreateCall(DFSF.DFS.DFSanLoadCallbackFn,
+        {IRB.CreateBitCast(LI.getPointerOperand(),
+        Type::getInt8PtrTy(*DFSF.DFS.Ctx)),
+        ConstantInt::get(DFSF.DFS.IntptrTy, Size), Shadow, PtrShadow});
   }
+
+  if (ClCombinePointerLabelsOnLoad)
+    Shadow = DFSF.combineShadows(Shadow, PtrShadow, &LI);
+
   if (Shadow != DFSF.DFS.ZeroShadow)
     DFSF.NonZeroChecks.push_back(Shadow);
 
   DFSF.setShadow(&LI, Shadow);
-  if (ClEventCallbacks) {
-    IRBuilder<> IRB(&LI);
-    IRB.CreateCall(DFSF.DFS.DFSanLoadCallbackFn, Shadow);
-  }
 }
 
 void DFSanFunction::storeShadow(Value *Addr, uint64_t Size, Align Alignment,
@@ -1397,6 +1504,13 @@ void DFSanFunction::storeShadow(Value *Addr, uint64_t Size, Align Alignment,
     }
   }
 
+  if (ClEnableKdfsan) {
+    IRBuilder<> IRB(Pos);
+    IRB.CreateCall(DFS.DFSanSetLabelFn, {Shadow, IRB.CreateBitCast(Addr,
+        Type::getInt8PtrTy(*DFS.Ctx)), ConstantInt::get(DFS.IntptrTy, Size)});
+    return;
+  }
+
   const Align ShadowAlign(Alignment.value() * DFS.ShadowWidthBytes);
   IRBuilder<> IRB(Pos);
   Value *ShadowAddr = DFS.getShadowAddress(Addr, Pos);
@@ -1448,15 +1562,25 @@ void DFSanVisitor::visitStoreInst(StoreInst &SI) {
   const Align Alignment = ClPreserveAlignment ? SI.getAlign() : Align(1);
 
   Value* Shadow = DFSF.getShadow(SI.getValueOperand());
-  if (ClCombinePointerLabelsOnStore) {
-    Value *PtrShadow = DFSF.getShadow(SI.getPointerOperand());
-    Shadow = DFSF.combineShadows(Shadow, PtrShadow, &SI);
-  }
-  DFSF.storeShadow(SI.getPointerOperand(), Size, Alignment, Shadow, &SI);
-  if (ClEventCallbacks) {
+
+  bool InsertStoreCallback =
+      DFSF.DFS.InsertCallbacks && SI.getMetadata("is-asan-instr");
+  Value *PtrShadow;
+  if(ClCombinePointerLabelsOnStore  || InsertStoreCallback)
+    PtrShadow = DFSF.getShadow(SI.getPointerOperand());
+
+  if (InsertStoreCallback) {
     IRBuilder<> IRB(&SI);
-    IRB.CreateCall(DFSF.DFS.DFSanStoreCallbackFn, Shadow);
+    Shadow = IRB.CreateCall(DFSF.DFS.DFSanStoreCallbackFn,
+    {IRB.CreateBitCast(SI.getPointerOperand(),
+    Type::getInt8PtrTy(*DFSF.DFS.Ctx)),
+    ConstantInt::get(DFSF.DFS.IntptrTy, Size), Shadow, PtrShadow});
   }
+
+  if (ClCombinePointerLabelsOnStore)
+    Shadow = DFSF.combineShadows(Shadow, PtrShadow, &SI);
+
+  DFSF.storeShadow(SI.getPointerOperand(), Size, Alignment, Shadow, &SI);
 }
 
 void DFSanVisitor::visitUnaryOperator(UnaryOperator &UO) {
@@ -1554,28 +1678,35 @@ void DFSanVisitor::visitMemSetInst(MemSetInst &I) {
 }
 
 void DFSanVisitor::visitMemTransferInst(MemTransferInst &I) {
-  IRBuilder<> IRB(&I);
-  Value *RawDestShadow = DFSF.DFS.getShadowAddress(I.getDest(), &I);
-  Value *SrcShadow = DFSF.DFS.getShadowAddress(I.getSource(), &I);
-  Value *LenShadow =
-      IRB.CreateMul(I.getLength(), ConstantInt::get(I.getLength()->getType(),
-                                                    DFSF.DFS.ShadowWidthBytes));
   Type *Int8Ptr = Type::getInt8PtrTy(*DFSF.DFS.Ctx);
-  Value *DestShadow = IRB.CreateBitCast(RawDestShadow, Int8Ptr);
-  SrcShadow = IRB.CreateBitCast(SrcShadow, Int8Ptr);
-  auto *MTI = cast<MemTransferInst>(
-      IRB.CreateCall(I.getFunctionType(), I.getCalledOperand(),
-                     {DestShadow, SrcShadow, LenShadow, I.getVolatileCst()}));
-  if (ClPreserveAlignment) {
-    MTI->setDestAlignment(I.getDestAlign() * DFSF.DFS.ShadowWidthBytes);
-    MTI->setSourceAlignment(I.getSourceAlign() * DFSF.DFS.ShadowWidthBytes);
-  } else {
-    MTI->setDestAlignment(Align(DFSF.DFS.ShadowWidthBytes));
-    MTI->setSourceAlignment(Align(DFSF.DFS.ShadowWidthBytes));
+  IRBuilder<> IRB(&I);
+
+  if (DFSF.DFS.InsertCallbacks) {
+    Value *Dest = IRB.CreateBitCast(I.getDest(), Int8Ptr);
+    Value *Src = IRB.CreateBitCast(I.getSource(), Int8Ptr);
+    Value *Size = IRB.CreateZExtOrTrunc(I.getLength(), DFSF.DFS.IntptrTy);
+    IRB.CreateCall(DFSF.DFS.DFSanMemTransferCallbackFn, {Dest, Src, Size});
   }
-  if (ClEventCallbacks) {
-    IRB.CreateCall(DFSF.DFS.DFSanMemTransferCallbackFn,
-                   {RawDestShadow, I.getLength()});
+
+  // KDFSAN's memtransfer callback (called above) handles the shadow memory
+  //   memtransfer
+  if (!ClEnableKdfsan) {
+    Value *RawDestShadow = DFSF.DFS.getShadowAddress(I.getDest(), &I);
+    Value *SrcShadow = DFSF.DFS.getShadowAddress(I.getSource(), &I);
+    Value *LenShadow = IRB.CreateMul(I.getLength(),
+        ConstantInt::get(I.getLength()->getType(), DFSF.DFS.ShadowWidthBytes));
+    Value *DestShadow = IRB.CreateBitCast(RawDestShadow, Int8Ptr);
+    SrcShadow = IRB.CreateBitCast(SrcShadow, Int8Ptr);
+    auto *MTI = cast<MemTransferInst>(
+        IRB.CreateCall(I.getFunctionType(), I.getCalledOperand(),
+                      {DestShadow, SrcShadow, LenShadow, I.getVolatileCst()}));
+    if (ClPreserveAlignment) {
+      MTI->setDestAlignment(I.getDestAlign() * DFSF.DFS.ShadowWidthBytes);
+      MTI->setSourceAlignment(I.getSourceAlign() * DFSF.DFS.ShadowWidthBytes);
+    } else {
+      MTI->setDestAlignment(Align(DFSF.DFS.ShadowWidthBytes));
+      MTI->setSourceAlignment(Align(DFSF.DFS.ShadowWidthBytes));
+    }
   }
 }
 
@@ -1604,6 +1735,10 @@ void DFSanVisitor::visitReturnInst(ReturnInst &RI) {
 
 void DFSanVisitor::visitCallBase(CallBase &CB) {
   Function *F = CB.getCalledFunction();
+  if (CB.isInlineAsm() && ClEnableKdfsan) {
+    DFSF.setShadow(&CB, DFSF.DFS.ZeroShadow);
+    return;
+  }
   if ((F && F->isIntrinsic()) || CB.isInlineAsm()) {
     visitOperandShadowInst(CB);
     return;
@@ -1616,6 +1751,11 @@ void DFSanVisitor::visitCallBase(CallBase &CB) {
 
   IRBuilder<> IRB(&CB);
 
+  if (CB.isIndirectCall() && ClKasperBranchChecks && !CB.getModule()->getName().contains("mm/kasan/")) {
+    Value *Shadow = DFSF.getShadow(CB.getCalledOperand());
+    IRB.CreateCall(DFSF.DFS.DFSanKasperBranchCheckFn, Shadow);
+  }
+
   DenseMap<Value *, Function *>::iterator i =
       DFSF.DFS.UnwrappedFnMap.find(CB.getCalledOperand());
   if (i != DFSF.DFS.UnwrappedFnMap.end()) {
@@ -1843,3 +1983,27 @@ void DFSanVisitor::visitPHINode(PHINode &PN) {
   DFSF.PHIFixups.push_back(std::make_pair(&PN, ShadowPN));
   DFSF.setShadow(&PN, ShadowPN);
 }
+
+void DFSanVisitor::visitBranchInst(BranchInst &I) {
+  if (ClKasperBranchChecks && I.isConditional() && !I.getModule()->getName().contains("mm/kasan/")) {
+    IRBuilder<> IRB(&I);
+    Value *Shadow = DFSF.getShadow(I.getCondition());
+    IRB.CreateCall(DFSF.DFS.DFSanKasperBranchCheckFn, Shadow);
+  }
+}
+
+void DFSanVisitor::visitSwitchInst(SwitchInst &I) {
+  if (ClKasperBranchChecks && !I.getModule()->getName().contains("mm/kasan/")) {
+    IRBuilder<> IRB(&I);
+    Value *Shadow = DFSF.getShadow(I.getCondition());
+    IRB.CreateCall(DFSF.DFS.DFSanKasperBranchCheckFn, Shadow);
+  }
+}
+
+void DFSanVisitor::visitIndirectBrInst(IndirectBrInst &I) {
+  if (ClKasperBranchChecks && !I.getModule()->getName().contains("mm/kasan/")) {
+    IRBuilder<> IRB(&I);
+    Value *Shadow = DFSF.getShadow(I.getAddress());
+    IRB.CreateCall(DFSF.DFS.DFSanKasperBranchCheckFn, Shadow);
+  }
+}
\ No newline at end of file
diff --git a/llvm/utils/benchmark/src/benchmark_register.h b/llvm/utils/benchmark/src/benchmark_register.h
index 0705e219f2f..4caa5ad4da0 100644
--- a/llvm/utils/benchmark/src/benchmark_register.h
+++ b/llvm/utils/benchmark/src/benchmark_register.h
@@ -1,6 +1,7 @@
 #ifndef BENCHMARK_REGISTER_H
 #define BENCHMARK_REGISTER_H
 
+#include <limits>
 #include <vector>
 
 #include "check.h"
-- 
2.43.0

